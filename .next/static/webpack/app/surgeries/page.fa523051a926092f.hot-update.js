"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/surgeries/page",{

/***/ "(app-pages-browser)/./src/lib/services/surgeries.ts":
/*!***************************************!*\
  !*** ./src/lib/services/surgeries.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   surgeriesService: function() { return /* binding */ surgeriesService; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\nconst surgeriesService = {\n    // Get all surgeries with room and doctor information\n    async getAll () {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").select(\"\\n        *,\\n        operating_rooms!inner(room_number),\\n        main_doctor:doctors!surgeries_main_doctor_id_fkey(name, specialty),\\n        secondary_doctor:doctors!surgeries_secondary_doctor_id_fkey(name, specialty)\\n      \").order(\"date\", {\n            ascending: true\n        }).order(\"time_slot\", {\n            ascending: true\n        });\n        if (error) throw error;\n        return data || [];\n    },\n    // Get surgeries for a specific date range\n    async getByDateRange (startDate, endDate) {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").select(\"\\n        *,\\n        operating_rooms!inner(room_number),\\n        main_doctor:doctors!surgeries_main_doctor_id_fkey(name, specialty),\\n        secondary_doctor:doctors!surgeries_secondary_doctor_id_fkey(name, specialty)\\n      \").gte(\"date\", startDate).lte(\"date\", endDate).order(\"date\", {\n            ascending: true\n        }).order(\"time_slot\", {\n            ascending: true\n        });\n        if (error) throw error;\n        return data || [];\n    },\n    // Get surgeries for a specific room\n    async getByRoom (roomId) {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").select(\"\\n        *,\\n        operating_rooms!inner(room_number),\\n        main_doctor:doctors!surgeries_main_doctor_id_fkey(name, specialty),\\n        secondary_doctor:doctors!surgeries_secondary_doctor_id_fkey(name, specialty)\\n      \").eq(\"room_id\", roomId).order(\"date\", {\n            ascending: true\n        }).order(\"time_slot\", {\n            ascending: true\n        });\n        if (error) throw error;\n        return data || [];\n    },\n    // Get a single surgery by ID\n    async getById (id) {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").select(\"\\n        *,\\n        operating_rooms!inner(room_number),\\n        main_doctor:doctors!surgeries_main_doctor_id_fkey(name, specialty),\\n        secondary_doctor:doctors!surgeries_secondary_doctor_id_fkey(name, specialty)\\n      \").eq(\"id\", id).single();\n        if (error) throw error;\n        return data;\n    },\n    // Check for scheduling conflicts\n    async checkConflict (surgeryData) {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").select(\"id\").eq(\"room_id\", surgeryData.room_id).eq(\"date\", surgeryData.date).eq(\"time_slot\", surgeryData.time_slot).single();\n        if (error && error.code !== \"PGRST116\") {\n            throw error;\n        }\n        if (data) {\n            return {\n                room_id: surgeryData.room_id,\n                date: surgeryData.date,\n                time_slot: surgeryData.time_slot,\n                existing_surgery_id: data.id\n            };\n        }\n        return null;\n    },\n    // Create a new surgery\n    async create (surgeryData) {\n        // First check for conflicts\n        const conflict = await this.checkConflict(surgeryData);\n        if (conflict) {\n            throw new Error(\"This time slot is already booked for this room on \".concat(surgeryData.date));\n        }\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").insert(surgeryData).select(\"\\n        *,\\n        operating_rooms!inner(room_number)\\n      \").single();\n        if (error) throw error;\n        return data;\n    },\n    // Update a surgery\n    async update (id, surgeryData) {\n        // If updating room, date, or time_slot, check for conflicts\n        if (surgeryData.room_id || surgeryData.date || surgeryData.time_slot) {\n            const currentSurgery = await this.getById(id);\n            if (!currentSurgery) {\n                throw new Error(\"Surgery not found\");\n            }\n            const checkData = {\n                room_id: surgeryData.room_id || currentSurgery.room_id,\n                date: surgeryData.date || currentSurgery.date,\n                time_slot: surgeryData.time_slot || currentSurgery.time_slot,\n                surgery_type: currentSurgery.surgery_type,\n                main_doctor_id: currentSurgery.main_doctor_id,\n                secondary_doctor_id: currentSurgery.secondary_doctor_id\n            };\n            const conflict = await this.checkConflict(checkData);\n            if (conflict && conflict.existing_surgery_id !== id) {\n                throw new Error(\"This time slot is already booked for this room on \".concat(checkData.date));\n            }\n        }\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").update(surgeryData).eq(\"id\", id).select(\"\\n        *,\\n        operating_rooms!inner(room_number)\\n      \").single();\n        if (error) throw error;\n        return data;\n    },\n    // Delete a surgery\n    async delete (id) {\n        const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").delete().eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Get surgeries for a specific week (Monday to Sunday)\n    async getByWeek (weekStart) {\n        const weekEnd = new Date(weekStart);\n        weekEnd.setDate(weekEnd.getDate() + 6);\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").select(\"\\n        *,\\n        operating_rooms!inner(room_number)\\n      \").gte(\"date\", weekStart).lte(\"date\", weekEnd.toISOString().split(\"T\")[0]).order(\"date\", {\n            ascending: true\n        }).order(\"time_slot\", {\n            ascending: true\n        });\n        if (error) throw error;\n        return data || [];\n    },\n    // Get available time slots for a specific room and date\n    async getAvailableSlots (roomId, date) {\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"surgeries\").select(\"time_slot\").eq(\"room_id\", roomId).eq(\"date\", date);\n        if (error) throw error;\n        const bookedSlots = (data === null || data === void 0 ? void 0 : data.map((s)=>s.time_slot)) || [];\n        const allSlots = [\n            \"morning\",\n            \"evening\"\n        ];\n        return allSlots.filter((slot)=>!bookedSlots.includes(slot));\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvc3VyZ2VyaWVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlDO0FBR2xDLE1BQU1DLG1CQUFtQjtJQUM5QixxREFBcUQ7SUFDckQsTUFBTUM7UUFDSixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUosbURBQVFBLENBQ25DSyxJQUFJLENBQUMsYUFDTEMsTUFBTSxDQUFFLHdPQU1SQyxLQUFLLENBQUMsUUFBUTtZQUFFQyxXQUFXO1FBQUssR0FDaENELEtBQUssQ0FBQyxhQUFhO1lBQUVDLFdBQVc7UUFBSztRQUV4QyxJQUFJSixPQUFPLE1BQU1BO1FBQ2pCLE9BQU9ELFFBQVEsRUFBRTtJQUNuQjtJQUVBLDBDQUEwQztJQUMxQyxNQUFNTSxnQkFBZUMsU0FBaUIsRUFBRUMsT0FBZTtRQUNyRCxNQUFNLEVBQUVSLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUosbURBQVFBLENBQ25DSyxJQUFJLENBQUMsYUFDTEMsTUFBTSxDQUFFLHdPQU1STSxHQUFHLENBQUMsUUFBUUYsV0FDWkcsR0FBRyxDQUFDLFFBQVFGLFNBQ1pKLEtBQUssQ0FBQyxRQUFRO1lBQUVDLFdBQVc7UUFBSyxHQUNoQ0QsS0FBSyxDQUFDLGFBQWE7WUFBRUMsV0FBVztRQUFLO1FBRXhDLElBQUlKLE9BQU8sTUFBTUE7UUFDakIsT0FBT0QsUUFBUSxFQUFFO0lBQ25CO0lBRUEsb0NBQW9DO0lBQ3BDLE1BQU1XLFdBQVVDLE1BQWM7UUFDNUIsTUFBTSxFQUFFWixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1KLG1EQUFRQSxDQUNuQ0ssSUFBSSxDQUFDLGFBQ0xDLE1BQU0sQ0FBRSx3T0FNUlUsRUFBRSxDQUFDLFdBQVdELFFBQ2RSLEtBQUssQ0FBQyxRQUFRO1lBQUVDLFdBQVc7UUFBSyxHQUNoQ0QsS0FBSyxDQUFDLGFBQWE7WUFBRUMsV0FBVztRQUFLO1FBRXhDLElBQUlKLE9B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QSxTQUFTQyxNQUFNLENBQUNDLENBQUFBLE9BQVEsQ0FBQ0wsWUFBWU0sUUFBUSxDQUFDRDtJQUN2RDtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zZXJ2aWNlcy9zdXJnZXJpZXMudHM/NTNjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJ1xuaW1wb3J0IHR5cGUgeyBTdXJnZXJ5LCBDcmVhdGVTdXJnZXJ5RGF0YSwgVXBkYXRlU3VyZ2VyeURhdGEsIFN1cmdlcnlDb25mbGljdCB9IGZyb20gJ0AvbGliL2RhdGEvc3VyZ2VyaWVzJ1xuXG5leHBvcnQgY29uc3Qgc3VyZ2VyaWVzU2VydmljZSA9IHtcbiAgLy8gR2V0IGFsbCBzdXJnZXJpZXMgd2l0aCByb29tIGFuZCBkb2N0b3IgaW5mb3JtYXRpb25cbiAgYXN5bmMgZ2V0QWxsKCk6IFByb21pc2U8U3VyZ2VyeVtdPiB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzdXJnZXJpZXMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIG9wZXJhdGluZ19yb29tcyFpbm5lcihyb29tX251bWJlciksXG4gICAgICAgIG1haW5fZG9jdG9yOmRvY3RvcnMhc3VyZ2VyaWVzX21haW5fZG9jdG9yX2lkX2ZrZXkobmFtZSwgc3BlY2lhbHR5KSxcbiAgICAgICAgc2Vjb25kYXJ5X2RvY3Rvcjpkb2N0b3JzIXN1cmdlcmllc19zZWNvbmRhcnlfZG9jdG9yX2lkX2ZrZXkobmFtZSwgc3BlY2lhbHR5KVxuICAgICAgYClcbiAgICAgIC5vcmRlcignZGF0ZScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG4gICAgICAub3JkZXIoJ3RpbWVfc2xvdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH0sXG5cbiAgLy8gR2V0IHN1cmdlcmllcyBmb3IgYSBzcGVjaWZpYyBkYXRlIHJhbmdlXG4gIGFzeW5jIGdldEJ5RGF0ZVJhbmdlKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBQcm9taXNlPFN1cmdlcnlbXT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc3VyZ2VyaWVzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBvcGVyYXRpbmdfcm9vbXMhaW5uZXIocm9vbV9udW1iZXIpLFxuICAgICAgICBtYWluX2RvY3Rvcjpkb2N0b3JzIXN1cmdlcmllc19tYWluX2RvY3Rvcl9pZF9ma2V5KG5hbWUsIHNwZWNpYWx0eSksXG4gICAgICAgIHNlY29uZGFyeV9kb2N0b3I6ZG9jdG9ycyFzdXJnZXJpZXNfc2Vjb25kYXJ5X2RvY3Rvcl9pZF9ma2V5KG5hbWUsIHNwZWNpYWx0eSlcbiAgICAgIGApXG4gICAgICAuZ3RlKCdkYXRlJywgc3RhcnREYXRlKVxuICAgICAgLmx0ZSgnZGF0ZScsIGVuZERhdGUpXG4gICAgICAub3JkZXIoJ2RhdGUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgLm9yZGVyKCd0aW1lX3Nsb3QnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9LFxuXG4gIC8vIEdldCBzdXJnZXJpZXMgZm9yIGEgc3BlY2lmaWMgcm9vbVxuICBhc3luYyBnZXRCeVJvb20ocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFN1cmdlcnlbXT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc3VyZ2VyaWVzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBvcGVyYXRpbmdfcm9vbXMhaW5uZXIocm9vbV9udW1iZXIpLFxuICAgICAgICBtYWluX2RvY3Rvcjpkb2N0b3JzIXN1cmdlcmllc19tYWluX2RvY3Rvcl9pZF9ma2V5KG5hbWUsIHNwZWNpYWx0eSksXG4gICAgICAgIHNlY29uZGFyeV9kb2N0b3I6ZG9jdG9ycyFzdXJnZXJpZXNfc2Vjb25kYXJ5X2RvY3Rvcl9pZF9ma2V5KG5hbWUsIHNwZWNpYWx0eSlcbiAgICAgIGApXG4gICAgICAuZXEoJ3Jvb21faWQnLCByb29tSWQpXG4gICAgICAub3JkZXIoJ2RhdGUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgLm9yZGVyKCd0aW1lX3Nsb3QnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9LFxuXG4gIC8vIEdldCBhIHNpbmdsZSBzdXJnZXJ5IGJ5IElEXG4gIGFzeW5jIGdldEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8U3VyZ2VyeSB8IG51bGw+IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3N1cmdlcmllcycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgb3BlcmF0aW5nX3Jvb21zIWlubmVyKHJvb21fbnVtYmVyKSxcbiAgICAgICAgbWFpbl9kb2N0b3I6ZG9jdG9ycyFzdXJnZXJpZXNfbWFpbl9kb2N0b3JfaWRfZmtleShuYW1lLCBzcGVjaWFsdHkpLFxuICAgICAgICBzZWNvbmRhcnlfZG9jdG9yOmRvY3RvcnMhc3VyZ2VyaWVzX3NlY29uZGFyeV9kb2N0b3JfaWRfZmtleShuYW1lLCBzcGVjaWFsdHkpXG4gICAgICBgKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBkYXRhXG4gIH0sXG5cbiAgLy8gQ2hlY2sgZm9yIHNjaGVkdWxpbmcgY29uZmxpY3RzXG4gIGFzeW5jIGNoZWNrQ29uZmxpY3Qoc3VyZ2VyeURhdGE6IENyZWF0ZVN1cmdlcnlEYXRhKTogUHJvbWlzZTxTdXJnZXJ5Q29uZmxpY3QgfCBudWxsPiB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzdXJnZXJpZXMnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCdyb29tX2lkJywgc3VyZ2VyeURhdGEucm9vbV9pZClcbiAgICAgIC5lcSgnZGF0ZScsIHN1cmdlcnlEYXRhLmRhdGUpXG4gICAgICAuZXEoJ3RpbWVfc2xvdCcsIHN1cmdlcnlEYXRhLnRpbWVfc2xvdClcbiAgICAgIC5zaW5nbGUoKVxuICAgIFxuICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7IC8vIFBHUlNUMTE2ID0gbm8gcm93cyByZXR1cm5lZFxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvb21faWQ6IHN1cmdlcnlEYXRhLnJvb21faWQsXG4gICAgICAgIGRhdGU6IHN1cmdlcnlEYXRhLmRhdGUsXG4gICAgICAgIHRpbWVfc2xvdDogc3VyZ2VyeURhdGEudGltZV9zbG90LFxuICAgICAgICBleGlzdGluZ19zdXJnZXJ5X2lkOiBkYXRhLmlkXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHN1cmdlcnlcbiAgYXN5bmMgY3JlYXRlKHN1cmdlcnlEYXRhOiBDcmVhdGVTdXJnZXJ5RGF0YSk6IFByb21pc2U8U3VyZ2VyeT4ge1xuICAgIC8vIEZpcnN0IGNoZWNrIGZvciBjb25mbGljdHNcbiAgICBjb25zdCBjb25mbGljdCA9IGF3YWl0IHRoaXMuY2hlY2tDb25mbGljdChzdXJnZXJ5RGF0YSlcbiAgICBpZiAoY29uZmxpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyB0aW1lIHNsb3QgaXMgYWxyZWFkeSBib29rZWQgZm9yIHRoaXMgcm9vbSBvbiAke3N1cmdlcnlEYXRhLmRhdGV9YClcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3N1cmdlcmllcycpXG4gICAgICAuaW5zZXJ0KHN1cmdlcnlEYXRhKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIG9wZXJhdGluZ19yb29tcyFpbm5lcihyb29tX251bWJlcilcbiAgICAgIGApXG4gICAgICAuc2luZ2xlKClcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgcmV0dXJuIGRhdGFcbiAgfSxcblxuICAvLyBVcGRhdGUgYSBzdXJnZXJ5XG4gIGFzeW5jIHVwZGF0ZShpZDogc3RyaW5nLCBzdXJnZXJ5RGF0YTogVXBkYXRlU3VyZ2VyeURhdGEpOiBQcm9taXNlPFN1cmdlcnk+IHtcbiAgICAvLyBJZiB1cGRhdGluZyByb29tLCBkYXRlLCBvciB0aW1lX3Nsb3QsIGNoZWNrIGZvciBjb25mbGljdHNcbiAgICBpZiAoc3VyZ2VyeURhdGEucm9vbV9pZCB8fCBzdXJnZXJ5RGF0YS5kYXRlIHx8IHN1cmdlcnlEYXRhLnRpbWVfc2xvdCkge1xuICAgICAgY29uc3QgY3VycmVudFN1cmdlcnkgPSBhd2FpdCB0aGlzLmdldEJ5SWQoaWQpXG4gICAgICBpZiAoIWN1cnJlbnRTdXJnZXJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VyZ2VyeSBub3QgZm91bmQnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGVja0RhdGE6IENyZWF0ZVN1cmdlcnlEYXRhID0ge1xuICAgICAgICByb29tX2lkOiBzdXJnZXJ5RGF0YS5yb29tX2lkIHx8IGN1cnJlbnRTdXJnZXJ5LnJvb21faWQsXG4gICAgICAgIGRhdGU6IHN1cmdlcnlEYXRhLmRhdGUgfHwgY3VycmVudFN1cmdlcnkuZGF0ZSxcbiAgICAgICAgdGltZV9zbG90OiBzdXJnZXJ5RGF0YS50aW1lX3Nsb3QgfHwgY3VycmVudFN1cmdlcnkudGltZV9zbG90LFxuICAgICAgICBzdXJnZXJ5X3R5cGU6IGN1cnJlbnRTdXJnZXJ5LnN1cmdlcnlfdHlwZSwgLy8gVXNlIGV4aXN0aW5nIHN1cmdlcnkgdHlwZSBmb3IgY29uZmxpY3QgY2hlY2tcbiAgICAgICAgbWFpbl9kb2N0b3JfaWQ6IGN1cnJlbnRTdXJnZXJ5Lm1haW5fZG9jdG9yX2lkLFxuICAgICAgICBzZWNvbmRhcnlfZG9jdG9yX2lkOiBjdXJyZW50U3VyZ2VyeS5zZWNvbmRhcnlfZG9jdG9yX2lkXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbmZsaWN0ID0gYXdhaXQgdGhpcy5jaGVja0NvbmZsaWN0KGNoZWNrRGF0YSlcbiAgICAgIGlmIChjb25mbGljdCAmJiBjb25mbGljdC5leGlzdGluZ19zdXJnZXJ5X2lkICE9PSBpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgdGltZSBzbG90IGlzIGFscmVhZHkgYm9va2VkIGZvciB0aGlzIHJvb20gb24gJHtjaGVja0RhdGEuZGF0ZX1gKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc3VyZ2VyaWVzJylcbiAgICAgIC51cGRhdGUoc3VyZ2VyeURhdGEpXG4gICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgb3BlcmF0aW5nX3Jvb21zIWlubmVyKHJvb21fbnVtYmVyKVxuICAgICAgYClcbiAgICAgIC5zaW5nbGUoKVxuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4gZGF0YVxuICB9LFxuXG4gIC8vIERlbGV0ZSBhIHN1cmdlcnlcbiAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3N1cmdlcmllcycpXG4gICAgICAuZGVsZXRlKClcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gIH0sXG5cbiAgLy8gR2V0IHN1cmdlcmllcyBmb3IgYSBzcGVjaWZpYyB3ZWVrIChNb25kYXkgdG8gU3VuZGF5KVxuICBhc3luYyBnZXRCeVdlZWsod2Vla1N0YXJ0OiBzdHJpbmcpOiBQcm9taXNlPFN1cmdlcnlbXT4ge1xuICAgIGNvbnN0IHdlZWtFbmQgPSBuZXcgRGF0ZSh3ZWVrU3RhcnQpXG4gICAgd2Vla0VuZC5zZXREYXRlKHdlZWtFbmQuZ2V0RGF0ZSgpICsgNilcbiAgICBcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3N1cmdlcmllcycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgb3BlcmF0aW5nX3Jvb21zIWlubmVyKHJvb21fbnVtYmVyKVxuICAgICAgYClcbiAgICAgIC5ndGUoJ2RhdGUnLCB3ZWVrU3RhcnQpXG4gICAgICAubHRlKCdkYXRlJywgd2Vla0VuZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pXG4gICAgICAub3JkZXIoJ2RhdGUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgLm9yZGVyKCd0aW1lX3Nsb3QnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9LFxuXG4gIC8vIEdldCBhdmFpbGFibGUgdGltZSBzbG90cyBmb3IgYSBzcGVjaWZpYyByb29tIGFuZCBkYXRlXG4gIGFzeW5jIGdldEF2YWlsYWJsZVNsb3RzKHJvb21JZDogc3RyaW5nLCBkYXRlOiBzdHJpbmcpOiBQcm9taXNlPCgnbW9ybmluZycgfCAnZXZlbmluZycpW10+IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3N1cmdlcmllcycpXG4gICAgICAuc2VsZWN0KCd0aW1lX3Nsb3QnKVxuICAgICAgLmVxKCdyb29tX2lkJywgcm9vbUlkKVxuICAgICAgLmVxKCdkYXRlJywgZGF0ZSlcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgXG4gICAgY29uc3QgYm9va2VkU2xvdHMgPSBkYXRhPy5tYXAocyA9PiBzLnRpbWVfc2xvdCkgfHwgW11cbiAgICBjb25zdCBhbGxTbG90czogKCdtb3JuaW5nJyB8ICdldmVuaW5nJylbXSA9IFsnbW9ybmluZycsICdldmVuaW5nJ11cbiAgICBcbiAgICByZXR1cm4gYWxsU2xvdHMuZmlsdGVyKHNsb3QgPT4gIWJvb2tlZFNsb3RzLmluY2x1ZGVzKHNsb3QpKVxuICB9XG59ICJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsInN1cmdlcmllc1NlcnZpY2UiLCJnZXRBbGwiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJnZXRCeURhdGVSYW5nZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJndGUiLCJsdGUiLCJnZXRCeVJvb20iLCJyb29tSWQiLCJlcSIsImdldEJ5SWQiLCJpZCIsInNpbmdsZSIsImNoZWNrQ29uZmxpY3QiLCJzdXJnZXJ5RGF0YSIsInJvb21faWQiLCJkYXRlIiwidGltZV9zbG90IiwiY29kZSIsImV4aXN0aW5nX3N1cmdlcnlfaWQiLCJjcmVhdGUiLCJjb25mbGljdCIsIkVycm9yIiwiaW5zZXJ0IiwidXBkYXRlIiwiY3VycmVudFN1cmdlcnkiLCJjaGVja0RhdGEiLCJzdXJnZXJ5X3R5cGUiLCJtYWluX2RvY3Rvcl9pZCIsInNlY29uZGFyeV9kb2N0b3JfaWQiLCJkZWxldGUiLCJnZXRCeVdlZWsiLCJ3ZWVrU3RhcnQiLCJ3ZWVrRW5kIiwiRGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImdldEF2YWlsYWJsZVNsb3RzIiwiYm9va2VkU2xvdHMiLCJtYXAiLCJzIiwiYWxsU2xvdHMiLCJmaWx0ZXIiLCJzbG90IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/surgeries.ts\n"));

/***/ })

});